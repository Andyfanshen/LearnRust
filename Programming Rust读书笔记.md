# Rust的基础使用
1. 通常使用rustup来安装Rust。rustup是一个管理Rust安装、更新的工具。使用rustup安装Rust会自动安装cargo、rustc和rustdoc工具。
2. cargo是Rust的编译管理工具、包管理工具以及通用工具。使用Cargo可以创建新的工程、构建和运行代码，以及管理依赖库。
3. rustc是Rust的编译器。我们通常使用Cargo来调度编译器，必要时也可以手动调用。
4. rustdoc是Rust的文档工具。如果在源码中以正确的形式书写注释，那么rustdoc就可以自动构建出格式美观的HTML文档。和rustc一样，我们通常使用Cargo来调度文档工具。
5. `debug_assert!`是一种特殊的断言，仅在debug模式下生效。
# Rust的基础类型
Rust的内存和线程安全性依赖于其健壮的类型系统，而Rust的灵活性则源于其泛型和特性（trait）。
1. Rust的基础数据类型都是围绕硬件中的固定宽度数据类型设计的，这满足了绝大多数应用的需求且可以运行得非常快，如果需要任意精度的类型，可以考虑使用`num`包。
2. 只有ASCII字符具有字节字面值（`b'x'`），结果为一个`u8`数值。
3. 也可以使用两位十六进制来强调这是一个ASCII字符的字节字面值（`b'\x1b'`），而不是单纯的数值`27u8`。
4. `(-4).abs()`将会报错，这是由于自动类型推断发生在检查完所有的方法调用之后，所以此处必须明确指明使用哪一种类型或是指明使用哪一种方法（此外，注意方法调用的优先级高于一元前缀运算符）。
5. 整型的方法通常可以分为四类：检查（`checked_div`）、覆盖（`wrapping_mul`）、填充（`saturating_sub`）和溢出（`overflowing_add`）。
6. 覆盖类返回结果对数据类型取模的值。有符号类型的取模可能会产生负值。
7. 填充类返回最接近数学结果的值。结果会被“钳制”在数据类型的范围内。填充类方法没有除法、求余和移位。
8. 溢出类返回一对结果`(result, overflowed)`，前者与覆盖类的计算一致，后者则为一个描述计算是否溢出的布尔类型。
9. 浮点类型的字面值最多由四部分构成：整数、小数（可以只有一个小数点）、指数和类型后缀。只有整数部分是必须要有的，但后三者至少存在一种。
10. 其他类型一般不能转换为布尔类型，但是布尔类型可以通过`as`转为整型，且`false`值转为`0`，`true`值转为`1`。
11. 虽然布尔类型只需要1bit表示，但Rust中使用了1byte存储，因而可以使用指针指向它。
12. 字符类型采用Unicode字符，每个字符为一个32bit值。
13. 字符串类型则采用UTF-8编码，这是一种变长编码。但对string或者&str使用`len()`方法时，得到的是其字节长度而不是字符数量。
14. 可以用形如`'\xHH'`的格式表示一个ASCII字符，用形如`'\u{HHHHHH}'`的格式表示一个Unicode字符。
15. 字符类型可以通过`as`转为整型类型，如果是转为小于32bit的整型，则截取掉高位部分。
16. 与之相反的是，只有`u8`整型可以通过`as`转为字符类型，但也可以通过`std::char::from_u32`函数实现。
17. Rust允许在并列的元素后尾随一个逗号，例如元组`("lonely hearts",)`，这有利于元素的增删，也有利于区分单元素的元组类型和括号表达式。
18. 可以使用`[N;V]`来快速初始化数组。
19. 虽然数组的方法通常都在切片上，但Rust在检索方法时会隐式地将数组引用转为切片，因此可以直接在数组上使用。
20. 由于slice引用既可以用于数组，也可以用于vector，因而适用于对数组或vector操作的函数。
21. 如果字符串字面值仅包含换行，则换行和次行开头的空格也会包含在字符串中；但如果行末以反斜杠结尾，则换行和次行开头的空格都会被舍弃。
22. 当需要使用包含复杂结构的原始字符串时，可以通过`r`+`#`+`""`+`#`的结构囊括起来，其中双引号前后的`#`数量保持一致。例如`r###"This raw string started with 'r###"'. Therefore it does not end until we reach a quote mark ('"') followed immediately by three pound signs ('###')."###`。
23. 虽然类型`&mut str`是存在的，但几乎没有什么能用的方法，只有`make_ascii_uppercase`和`make_ascii_lowercase`可以使用。
24. 对str字面值使用`to_string()`方法和`to_owned()`方法具有一样的效果。
# 所有权和移动语义
1. Vector不支持直接移动其中的某个值，因为这通常需要额外的信息来记录那些位置变为未定义的。一般通过借用来访问Vector中的值，如果需要移动，则可以考虑使用`pop()`、`swap_remove()`、`replace()`等方法。
2. 对于Option类型的实例，如果需要取出其中的值并转移所有权，则可以使用`take()`方法，转移后将在原变量处留下`None`值。
3. 整型、浮点型、字符类型、布尔类型等在内的基础类型都是Copy类型，由它们组成的元组类型和定长数组也是Copy类型。
4. 只有可以按位复制的类型可以是Copy类型，File类型不是Copy类型，MutexGuard类型也不是Copy类型。只有成员都是Copy类型，复合类型才可以是Copy类型（默认不是，需要添加属性`#[derive(Copy, Clone)]`）。
5. 一般来说，如果某种类型在释放时需要特殊操作，则不会是Copy类型。例如，Vec类型需要释放各元素占用的内存，File类型需要关闭文件，MutexGuard需要给互斥器解锁。
6. 引用计数指针`Rc<T>`所指向的值不能改变，这避免了产生循环引用。“内部可变性”是一类特殊的机制，允许修改那些本身可变的值。
7. 不可变借用的类型为`&T`，可以同时存在多个，且不可变借用的赋值是通过拷贝实现的；可变借用的类型为`&mut T`，同时只能存在一个，且可变借用没有Copy Trait。
8. 与C++不同的是，Rust中的引用是可以改动的，初始指向A的引用可以修改为指向B，而C++中的引用一旦初始化完成便不可修改。
9. 与`.`操作符相似，Rust中的比较操作符也可以自动解析任意数量的引用。
10. `std::ptr::eq`可用于判断两个引用是否指向同一个内存地址。
11. 对于临时创建的数据的引用，数据生命周期的长度取决于引用的使用：如果该引用立即赋予一个独立变量或成员变量，则生命周期与变量相同；否则生命周期将在该语句结束时终止。
12. 类型定义中出现的引用类型需要显式标注它的生命周期。
13. 即使是`i32`也是有生命周期的，但像`i32`和`String`这样的数据通常是`'static`的，因此`Vec<i32>`也具有独立的生命周期；但`Vec<&'a i32>`就具有确定的生命周期，必须包含在`'a`之内。
14. 当存在多个生命周期可用时，编译器会选择使用最小的那个。
# 表达式
1. Rust是表达式语言，这一点与C系语言不同。Rust中`if`和`match`语法是可以产生值并赋予其他变量的。
2. 虽然可以在语句块中定义函数，但仍不能直接使用当前语句块中的变量。捕获当前范围内的变量需要使用闭包。
3. `match`语法会保证分支覆盖所有可能，并具有相同的表达式（值）类型。
4. `if let`是一种简写语法，`if let`完全可以由`match`代替，通常只有单值匹配时才使用`if let`语法。
5. Rust中的循环也是一种表达式，但`for`循环和`while`循环的值都是没有太大意义的`()`，只有`loop`循环可以指定表达式值。
6. 范围操作符`..`会产生一个范围类型，范围类型由两个字段组成，一个是开始字段，另一个是结束字段。范围类型是一种可迭代类型（实现了`std::iter::IntoIterator`特性）。
7. 与移动语义保持一致，`for`循环会消耗掉（移动）所迭代的对象。如果希望保持原位，可以改为对其引用的迭代。
8. `loop`循环可以通过`break`语法指定其表达式值，`break`语法也只能用在循环语法中。
9. 循环语法也可以标注生命周期，此时，循环内部的`break`语法可以指定生命周期来跳出循环，`continue`语法也可以指定生命周期来进入下一轮循环。（`break`语法可以同时指定生命周期和循环表达式的值）
10. 部分特殊的表达式并不能指定表达式值（例如死循环、`panic!()`等），对于这类特殊的表达式，它们使用一种特殊的值类型：`!`，该类型意味着表达式不会返回任何值，是发散函数。
11. 当需要指定泛型函数的特化类型时，可以通过`turbofish`语法实现：`return Vec::<i32>::with_capacity(1000);`
12. 与C语言不同，Rust中的按位操作优先级高于比较运算。
13. 与C语言不同，Rust不支持链式赋值。
14. 从浮点类型向整型转换会发生向零截取（`-1.99 as i32` 为 -1）。
15. 闭包既可以在定义时指明参数类型，也可以由编译器根据上下文内容推断（函数则必须指明类型）。闭包如果有返回值，则主体部分必须由语句块构成（语句块才能形成表达式并返回值）。
# 错误处理
1. 当发生`panic`时，Rust会进行堆栈展开（unwind）或是中断进程，默认行为是unwind。堆栈展开会根据栈中顺序释放临时变量和过程参数（内存被释放，打开的文件被关闭，调用相关的drop方法）。
2. `panic`是有确定行为的运行时异常，它是安全的，并不会引发内存泄漏之类的问题。发生`panic`意味着程序未按期望的方式运行，出现了需要修复的逻辑错误。
3. `panic`是逐线程的，这意味着某条线程发生`panic`时，其他线程仍然可以正常运作。
4. 堆栈展开也可以通过`std::panic::catch_unwind()`捕获，这在编写一些交由C或C++调用的Rust代码时很有必要。
5. 当执行drop方法时若再次发生`panic`，一般认为发生了致命错误，Rust不再进行unwind，而是直接中断进程。
6. Rust的`panic`行为是可以通过编译器指令控制的，如果指定直接中断进程，则Rust不再在发生`panic`时进行unwind（一定程度上也可以减小编译出来的文件大小）。
7. Rust的另一种错误处理方式与其他语言中的try/catch语法相似，是`Result<T, E>`类型。
8. 可以通过`err.source()`去溯源上一级错误。
9. `?`操作符用于错误传播。当发生错误时会立即返回包含错误的`Result`值。
10. 当需要自定义错误类型时，可以考虑引入`thiserror`包。
11. 标准库的错误类型都满足trait对象`Box<dyn std::error::Error + Send + Sync + 'static>`。
12. 标准库的错误类型具有`downcast_ref::<ErrorType>()`方法，可以从一般性的错误类型细化。
13. 