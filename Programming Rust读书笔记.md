# Rust的基础使用
1. 通常使用rustup来安装Rust。rustup是一个管理Rust安装、更新的工具。使用rustup安装Rust会自动安装cargo、rustc和rustdoc工具。
2. cargo是Rust的编译管理工具、包管理工具以及通用工具。使用Cargo可以创建新的工程、构建和运行代码，以及管理依赖库。
3. rustc是Rust的编译器。我们通常使用Cargo来调度编译器，必要时也可以手动调用。
4. rustdoc是Rust的文档工具。如果在源码中以正确的形式书写注释，那么rustdoc就可以自动构建出格式美观的HTML文档。和rustc一样，我们通常使用Cargo来调度文档工具。
5. `debug_assert!`是一种特殊的断言，仅在debug模式下生效。
6. `raw string`保留原始字符串内容，以`r`开头，紧跟0~n个`#`字符，中间是用双引号包裹的任意unicode字符序列，然后以同样数量的`#`字符结束。
# Rust的基础类型
Rust的内存和线程安全性依赖于其健壮的类型系统，而Rust的灵活性则源于其泛型和特性（trait）。
1. Rust的基础数据类型都是围绕硬件中的固定宽度数据类型设计的，这满足了绝大多数应用的需求且可以运行得非常快，如果需要任意精度的类型，可以考虑使用`num`包。
2. 只有ASCII字符具有字节字面值（`b'x'`），结果为一个`u8`数值。
3. 也可以使用两位十六进制来强调这是一个ASCII字符的字节字面值（`b'\x1b'`），而不是单纯的数值`27u8`。
4. `(-4).abs()`将会报错，这是由于自动类型推断发生在检查完所有的方法调用之后，所以此处必须明确指明使用哪一种类型或是指明使用哪一种方法（此外，注意方法调用的优先级高于一元前缀运算符）。
5. 整型的方法通常可以分为四类：检查（`checked_div`）、覆盖（`wrapping_mul`）、填充（`saturating_sub`）和溢出（`overflowing_add`）。
6. 覆盖类返回结果对数据类型取模的值。有符号类型的取模可能会产生负值。
7. 填充类返回最接近数学结果的值。结果会被“钳制”在数据类型的范围内。填充类方法没有除法、求余和移位。
8. 溢出类返回一对结果`(result, overflowed)`，前者与覆盖类的计算一致，后者则为一个描述计算是否溢出的布尔类型。
9. 浮点类型的字面值最多由四部分构成：整数、小数（可以只有一个小数点）、指数和类型后缀。只有整数部分是必须要有的，但后三者至少存在一种。
10. 其他类型一般不能转换为布尔类型，但是布尔类型可以通过`as`转为整型，且`false`值转为`0`，`true`值转为`1`。
11. 虽然布尔类型只需要1bit表示，但Rust中使用了1byte存储，因而可以使用指针指向它。
12. 字符类型采用Unicode字符，每个字符为一个32bit值。
13. 字符串类型则采用UTF-8编码。
14. 可以用形如`'\xHH'`的格式表示一个ASCII字符，用形如`'\u{HHHHHH}'`的格式表示一个Unicode字符。