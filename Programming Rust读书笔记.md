# Rust的基础使用
1. 通常使用rustup来安装Rust。rustup是一个管理Rust安装、更新的工具。使用rustup安装Rust会自动安装cargo、rustc和rustdoc工具。
2. cargo是Rust的编译管理工具、包管理工具以及通用工具。使用Cargo可以创建新的工程、构建和运行代码，以及管理依赖库。
3. rustc是Rust的编译器。我们通常使用Cargo来调度编译器，必要时也可以手动调用。
4. rustdoc是Rust的文档工具。如果在源码中以正确的形式书写注释，那么rustdoc就可以自动构建出格式美观的HTML文档。和rustc一样，我们通常使用Cargo来调度文档工具。
5. `debug_assert!`是一种特殊的断言，仅在debug模式下生效。
# Rust的基础类型
Rust的内存和线程安全性依赖于其健壮的类型系统，而Rust的灵活性则源于其泛型和特性（trait）。
1. Rust的基础数据类型都是围绕硬件中的固定宽度数据类型设计的，这满足了绝大多数应用的需求且可以运行得非常快，如果需要任意精度的类型，可以考虑使用`num`包。
2. 只有ASCII字符具有字节字面值（`b'x'`），结果为一个`u8`数值。
3. 也可以使用两位十六进制来强调这是一个ASCII字符的字节字面值（`b'\x1b'`），而不是单纯的数值`27u8`。
4. `(-4).abs()`将会报错，这是由于自动类型推断发生在检查完所有的方法调用之后，所以此处必须明确指明使用哪一种类型或是指明使用哪一种方法（此外，注意方法调用的优先级高于一元前缀运算符）。
5. 整型的方法通常可以分为四类：检查（`checked_div`）、覆盖（`wrapping_mul`）、填充（`saturating_sub`）和溢出（`overflowing_add`）。
6. 覆盖类返回结果对数据类型取模的值。有符号类型的取模可能会产生负值。
7. 填充类返回最接近数学结果的值。结果会被“钳制”在数据类型的范围内。填充类方法没有除法、求余和移位。
8. 溢出类返回一对结果`(result, overflowed)`，前者与覆盖类的计算一致，后者则为一个描述计算是否溢出的布尔类型。
9. 浮点类型的字面值最多由四部分构成：整数、小数（可以只有一个小数点）、指数和类型后缀。只有整数部分是必须要有的，但后三者至少存在一种。
10. 其他类型一般不能转换为布尔类型，但是布尔类型可以通过`as`转为整型，且`false`值转为`0`，`true`值转为`1`。
11. 虽然布尔类型只需要1bit表示，但Rust中使用了1byte存储，因而可以使用指针指向它。
12. 字符类型采用Unicode字符，每个字符为一个32bit值。
13. 字符串类型则采用UTF-8编码，这是一种变长编码。但对string或者&str使用`len()`方法时，得到的是其字节长度而不是字符数量。
14. 可以用形如`'\xHH'`的格式表示一个ASCII字符，用形如`'\u{HHHHHH}'`的格式表示一个Unicode字符。
15. 字符类型可以通过`as`转为整型类型，如果是转为小于32bit的整型，则截取掉高位部分。
16. 与之相反的是，只有`u8`整型可以通过`as`转为字符类型，但也可以通过`std::char::from_u32`函数实现。
17. Rust允许在并列的元素后尾随一个逗号，例如元组`("lonely hearts",)`，这有利于元素的增删，也有利于区分单元素的元组类型和括号表达式。
18. 可以使用`[N;V]`来快速初始化数组。
19. 虽然数组的方法通常都在切片上，但Rust在检索方法时会隐式地将数组引用转为切片，因此可以直接在数组上使用。
20. 由于slice引用既可以用于数组，也可以用于vector，因而适用于对数组或vector操作的函数。
21. 如果字符串字面值仅包含换行，则换行和次行开头的空格也会包含在字符串中；但如果行末以反斜杠结尾，则换行和次行开头的空格都会被舍弃。
22. 当需要使用包含复杂结构的原始字符串时，可以通过`r`+`#`+`""`+`#`的结构囊括起来，其中双引号前后的`#`数量保持一致。例如`r###"This raw string started with 'r###"'. Therefore it does not end until we reach a quote mark ('"') followed immediately by three pound signs ('###')."###`。
23. 虽然类型`&mut str`是存在的，但几乎没有什么能用的方法，只有`make_ascii_uppercase`和`make_ascii_lowercase`可以使用。
24. 对str字面值使用`to_string()`方法和`to_owned()`方法具有一样的效果。
# 所有权和移动语义
1. Vector不支持直接移动其中的某个值，因为这通常需要额外的信息来记录那些位置变为未定义的。一般通过借用来访问Vector中的值，如果需要移动，则可以考虑使用`pop()`、`swap_remove()`、`replace()`等方法。
2. 对于Option类型的实例，如果需要取出其中的值并转移所有权，则可以使用`take()`方法，转移后将在原变量出留下`None`值。
3. 整型、浮点型、字符类型、布尔类型等在内的基础类型都是Copy类型，由它们组成的元组类型和定长数组也是Copy类型。
4. 只有可以按位复制的类型可以是Copy类型，File类型不是Copy类型，MutexGuard类型也不是Copy类型。只有成员都是Copy类型，复合类型才可以是Copy类型（默认不是，需要添加属性`#[derive(Copy, Clone)]`）。
5. 一般来说，如果某种类型在释放时需要特殊操作，则不会是Copy类型。例如，Vec类型需要释放各元素占用的内存，File类型需要关闭文件，MutexGuard需要给互斥器解锁。
6. 引用计数指针`Rc<T>`所指向的值不能改变，这避免了产生循环引用。“内部可变性”是一类特殊的机制，允许修改那些本身可变的值。
7. 不可变借用的类型为`&T`，可以同时存在多个，且不可变借用的赋值是通过拷贝实现的；可变借用的类型为`&mut T`，同时只能存在一个，且可变借用没有Copy Trait。
8. 与C++不同的是，Rust中的引用是可以改动的，初始指向A的引用可以修改为指向B，而C++中的引用一旦初始化完成便不可修改。
9. 与`.`操作符相似，Rust中的比较操作符也可以自动解析任意数量的引用。
10. `std::ptr::eq`可用于判断两个引用是否指向同一个内存地址。
11. 对于临时创建的数据的引用，数据生命周期的长度取决于引用的使用：如果该引用立即赋予一个独立变量或成员变量，则生命周期与变量相同；否则生命周期将在该语句结束时终止。
12. 类型定义中出现的引用类型需要显式标注它的生命周期。
13. 即使是`i32`也是有生命周期的，但像`i32`和`String`这样的数据通常是`'static`的，因此`Vec<i32>`也具有独立的生命周期；但`Vec<&'a i32>`就具有确定的生命周期，必须包含在`'a`之内。